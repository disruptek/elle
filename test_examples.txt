ELLE2 TEST COVERAGE - CONCRETE TEST EXAMPLES
==============================================

EXAMPLE 1: Unit Tests for src/compiler/capture_resolution.rs
============================================================

Add this #[cfg(test)] mod tests block to the end of capture_resolution.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::compiler::ast::{Expr};
    use crate::value::SymbolId;

    fn make_sym(id: u32) -> SymbolId {
        SymbolId(id)
    }

    /// Test a lambda with no captures (simplest case)
    #[test]
    fn test_single_lambda_no_captures() {
        let mut expr = Expr::Lambda {
            params: vec![make_sym(1), make_sym(2)],
            body: Box::new(Expr::Var(make_sym(1), 0, 0)), // param 1 at depth 0, index 0
            captures: vec![],
        };

        resolve_captures(&mut expr);

        // After resolution, no changes expected for single lambda with no captures
        if let Expr::Lambda { captures, .. } = expr {
            assert_eq!(captures.len(), 0);
        } else {
            panic!("Expected Lambda expression");
        }
    }

    /// Test a lambda that captures from outer scope
    #[test]
    fn test_lambda_with_captures() {
        let mut expr = Expr::Lambda {
            params: vec![make_sym(1)],
            body: Box::new(Expr::Lambda {
                params: vec![make_sym(2)],
                body: Box::new(Expr::Var(make_sym(0), 0, 0)), // captured var at depth 0
                captures: vec![(make_sym(0), 0, 0)], // capture from outer scope
            }),
            captures: vec![],
        };

        resolve_captures(&mut expr);

        // The inner lambda's capture index should be adjusted
        if let Expr::Lambda {
            body: inner_lambda, ..
        } = expr
        {
            if let Expr::Lambda { captures, .. } = &**inner_lambda {
                assert!(!captures.is_empty(), "Inner lambda should have captures");
                // Index should have been adjusted for outer lambda's captures
            }
        }
    }

    /// Test deeply nested lambdas
    #[test]
    fn test_deeply_nested_lambda_captures() {
        // Create: (lambda (a) (lambda (b) (lambda (c) a)))
        // The innermost lambda captures 'a' from the outermost scope
        let mut expr = Expr::Lambda {
            params: vec![make_sym(0)], // a
            body: Box::new(Expr::Lambda {
                params: vec![make_sym(1)], // b
                body: Box::new(Expr::Lambda {
                    params: vec![make_sym(2)], // c
                    body: Box::new(Expr::Var(make_sym(0), 2, 0)), // reference to 'a'
                    captures: vec![(make_sym(0), 2, 0)],
                }),
                captures: vec![],
            }),
            captures: vec![],
        };

        resolve_captures(&mut expr);
        // Should not panic and should properly resolve all capture indices
    }

    /// Test capture with local shadowing
    #[test]
    fn test_capture_with_local_shadowing() {
        // Outer scope has 'x', inner lambda redefines 'x'
        // Reference to 'x' in inner lambda should refer to local, not captured
        let mut expr = Expr::Lambda {
            params: vec![make_sym(0)], // outer x
            body: Box::new(Expr::Lambda {
                params: vec![make_sym(0)], // inner x (shadows outer)
                body: Box::new(Expr::Var(make_sym(0), 0, 0)), // refers to inner x
                captures: vec![],
            }),
            captures: vec![],
        };

        resolve_captures(&mut expr);
        // Should handle shadowing correctly
    }
}
```

EXAMPLE 2: Integration Tests for src/compiler/converters.rs
===========================================================

Create tests/integration/compiler/conversion_tests.rs:

```rust
use elle::compiler::converters::value_to_expr;
use elle::{read_str, SymbolTable, Value};

#[test]
fn test_literal_conversion() {
    let mut symbols = SymbolTable::new();
    
    // Test integer literal
    let value = Value::Int(42);
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "Integer literal should convert: {:?}", result);
    
    // Test float literal
    let value = Value::Float(3.14);
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "Float literal should convert: {:?}", result);
    
    // Test string literal
    let value = Value::String("hello".into());
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "String literal should convert: {:?}", result);
}

#[test]
fn test_lambda_conversion() {
    let mut symbols = SymbolTable::new();
    
    // Parse a lambda: (lambda (x) x)
    let code = "(lambda (x) x)";
    let value = read_str(code, &mut symbols).expect("Failed to parse lambda");
    
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "Lambda should convert: {:?}", result);
}

#[test]
fn test_let_binding_conversion() {
    let mut symbols = SymbolTable::new();
    
    // Parse: (let ((x 1) (y 2)) (+ x y))
    let code = "(let ((x 1) (y 2)) (+ x y))";
    let value = read_str(code, &mut symbols).expect("Failed to parse let");
    
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "Let binding should convert: {:?}", result);
}

#[test]
fn test_error_on_invalid_lambda() {
    let mut symbols = SymbolTable::new();
    
    // Lambda with non-list parameters should error
    let code = "(lambda 42 x)"; // Invalid: parameters must be a list
    let value = read_str(code, &mut symbols).expect("Failed to parse");
    
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_err(), "Invalid lambda should produce error");
}

#[test]
fn test_nested_expressions() {
    let mut symbols = SymbolTable::new();
    
    // Parse nested: (lambda (f) (lambda (x) (f x)))
    let code = "(lambda (f) (lambda (x) (f x)))";
    let value = read_str(code, &mut symbols).expect("Failed to parse");
    
    let result = value_to_expr(&value, &mut symbols);
    assert!(result.is_ok(), "Nested expressions should convert: {:?}", result);
}
```

EXAMPLE 3: Integration Tests for src/primitives/arithmetic.rs
=============================================================

Create tests/integration/primitives/arithmetic_tests.rs:

```rust
use elle::{compile, read_str, register_primitives, SymbolTable, Value, VM};

fn eval(code: &str) -> Result<Value, String> {
    let mut vm = VM::new();
    let mut symbols = SymbolTable::new();
    register_primitives(&mut vm, &mut symbols);
    
    let value = read_str(code, &mut symbols)?;
    let expr = elle::compiler::converters::value_to_expr(&value, &mut symbols)?;
    let bytecode = compile(&expr);
    vm.execute(&bytecode)
}

#[test]
fn test_add_basic() {
    let result = eval("(+ 1 2 3)").expect("Failed to eval");
    assert_eq!(result, Value::Int(6));
}

#[test]
fn test_add_empty() {
    let result = eval("(+)").expect("Failed to eval");
    assert_eq!(result, Value::Int(0)); // Identity element
}

#[test]
fn test_subtract() {
    let result = eval("(- 10 3 2)").expect("Failed to eval");
    assert_eq!(result, Value::Int(5));
}

#[test]
fn test_subtract_single() {
    let result = eval("(- 5)").expect("Failed to eval");
    assert_eq!(result, Value::Int(-5)); // Negation
}

#[test]
fn test_multiply_basic() {
    let result = eval("(* 2 3 4)").expect("Failed to eval");
    assert_eq!(result, Value::Int(24));
}

#[test]
fn test_multiply_empty() {
    let result = eval("(*)").expect("Failed to eval");
    assert_eq!(result, Value::Int(1)); // Identity element
}

#[test]
fn test_divide_basic() {
    let result = eval("(/ 24 2 3)").expect("Failed to eval");
    assert_eq!(result, Value::Int(4));
}

#[test]
fn test_division_by_zero_error() {
    let result = eval("(/ 1 0)");
    assert!(result.is_err(), "Division by zero should error");
}

#[test]
fn test_mixed_int_float_arithmetic() {
    let result = eval("(+ 1 2.5)").expect("Failed to eval");
    assert_eq!(result, Value::Float(3.5));
}

#[test]
fn test_arithmetic_type_error() {
    let result = eval("(+ 1 \"string\")");
    assert!(result.is_err(), "Adding int and string should error");
}

#[test]
fn test_modulo() {
    let result = eval("(mod 17 5)").expect("Failed to eval");
    assert_eq!(result, Value::Int(2));
}
```

EXAMPLE 4: Unit Tests for src/ffi/marshal/cvalue.rs
===================================================

Add to cvalue.rs:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_int_to_raw_bytes() {
        let val = CValue::Int(0x0102030405060708i64);
        let bytes = val.as_raw();
        assert_eq!(bytes.len(), 8);
        assert_eq!(bytes, vec![0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01]);
    }

    #[test]
    fn test_uint_to_raw_bytes() {
        let val = CValue::UInt(0x0102030405060708u64);
        let bytes = val.as_raw();
        assert_eq!(bytes.len(), 8);
    }

    #[test]
    fn test_float_to_raw_bytes() {
        let val = CValue::Float(1.0);
        let bytes = val.as_raw();
        assert_eq!(bytes.len(), 8);
        // IEEE 754 representation of 1.0
        assert_eq!(bytes, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f]);
    }

    #[test]
    fn test_cvalue_equality() {
        let a = CValue::Int(42);
        let b = CValue::Int(42);
        assert_eq!(a, b);
    }

    #[test]
    fn test_cvalue_struct_clone() {
        let val = CValue::Struct(vec![1, 2, 3, 4]);
        let cloned = val.clone();
        assert_eq!(val, cloned);
    }
}
```

EXAMPLE 5: VM Integration Test
==============================

Create tests/integration/vm/instruction_tests.rs:

```rust
use elle::{compile, read_str, register_primitives, SymbolTable, Value, VM};

fn run_code(code: &str) -> Result<Value, String> {
    let mut vm = VM::new();
    let mut symbols = SymbolTable::new();
    register_primitives(&mut vm, &mut symbols);
    
    let value = read_str(code, &mut symbols)?;
    let expr = elle::compiler::converters::value_to_expr(&value, &mut symbols)?;
    let bytecode = compile(&expr);
    vm.execute(&bytecode)
}

#[test]
fn test_simple_literal() {
    let result = run_code("42").expect("Failed to execute");
    assert_eq!(result, Value::Int(42));
}

#[test]
fn test_arithmetic_sequence() {
    let result = run_code("(+ (* 2 3) (- 10 2))").expect("Failed to execute");
    assert_eq!(result, Value::Int(14)); // (6 + 8)
}

#[test]
fn test_if_expression_true() {
    let result = run_code("(if #t 1 2)").expect("Failed to execute");
    assert_eq!(result, Value::Int(1));
}

#[test]
fn test_if_expression_false() {
    let result = run_code("(if #f 1 2)").expect("Failed to execute");
    assert_eq!(result, Value::Int(2));
}

#[test]
fn test_lambda_creation() {
    let result = run_code("(lambda (x) (+ x 1))").expect("Failed to execute");
    match result {
        Value::Closure(_) => {}, // Expected
        _ => panic!("Expected closure, got {:?}", result),
    }
}

#[test]
fn test_lambda_invocation() {
    let result = run_code("((lambda (x) (+ x 1)) 5)").expect("Failed to execute");
    assert_eq!(result, Value::Int(6));
}

#[test]
fn test_nested_lambda() {
    let result = run_code("((lambda (x) (lambda (y) (+ x y))) 3) 4")
        .expect("Failed to execute");
    assert_eq!(result, Value::Int(7));
}

#[test]
fn test_list_operations() {
    let result = run_code("(list 1 2 3)").expect("Failed to execute");
    let vec = result.list_to_vec().expect("Failed to convert to vec");
    assert_eq!(vec.len(), 3);
    assert_eq!(vec[0], Value::Int(1));
    assert_eq!(vec[1], Value::Int(2));
    assert_eq!(vec[2], Value::Int(3));
}

#[test]
fn test_car_cdr() {
    let result = run_code("(car (list 1 2 3))").expect("Failed to execute");
    assert_eq!(result, Value::Int(1));
    
    let result = run_code("(car (cdr (list 1 2 3)))").expect("Failed to execute");
    assert_eq!(result, Value::Int(2));
}
```

TESTING CHECKLIST FOR EACH MODULE
==================================

For each untested module, ensure:

□ Setup/Teardown: Define fixtures or helper functions for module setup
□ Positive Cases: Test normal operation with valid inputs
□ Negative Cases: Test error handling with invalid inputs
□ Edge Cases: Test boundary conditions (empty, null, max values)
□ Integration: Test interaction with dependent modules
□ Documentation: Add comments explaining complex test logic
□ Performance: Add benchmarks for hot paths (optional)
□ Coverage: Aim for 80%+ code coverage

RUNNING TESTS
=============

# Run all tests
cargo test

# Run specific test file
cargo test --test integration/compiler/conversion_tests

# Run with output
cargo test -- --nocapture

# Run specific test function
cargo test test_capture_resolution

# Check coverage (requires tarpaulin)
cargo tarpaulin --out Html

