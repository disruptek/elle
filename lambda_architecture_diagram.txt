================================================================================
              ELLE4 LAMBDA COMPILATION ARCHITECTURE
================================================================================

INPUT: Scheme S-expression
  (lambda (x) (+ x (lambda (y) (+ x y))))
              │
              │
              ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                         STAGE 1: CONVERTER                                    │
│                    (Value → Expr AST + Scope Tracking)                        │
│                                                                               │
│  File: src/compiler/converters.rs                                            │
│  Function: convert_lambda() + helpers                                        │
│                                                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 1. Parse lambda parameters                                             │  │
│  │    Extract: [x]                                                        │  │
│  │    Push to scope_stack: [[x]]                                          │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 2. Pre-register defines (enable recursion)                             │  │
│  │    Pre-scan body for: (define f ...)                                   │  │
│  │    Add to scope: [x, f]                                                │  │
│  │    Now f is visible before its value is parsed                         │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 3. Parse body expressions                                              │  │
│  │    For each expression, call value_to_expr_with_scope()               │  │
│  │    Track variable references against scope_stack                       │  │
│  │    Mark references with (symbol, depth, index)                         │  │
│  │                                                                         │  │
│  │    Example: (+ x y)                                                    │  │
│  │    x → Var(x, 0, 0)  // depth=0: parameter, index=0                  │  │
│  │    y → Var(y, 1, 1)  // depth=1: outer scope, index=1               │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 4. Analyze free variables (call analyze_free_vars)                     │  │
│  │    Find vars referenced but not bound locally                          │  │
│  │    For outer lambdas: y is free (not a parameter)                      │  │
│  │    Filter out locally-defined variables from free set                  │  │
│  │    Result: captures = [(y, 1, 1)]                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 5. Dead capture elimination                                            │  │
│  │    Use analyze_capture_usage() to check which captures are actually    │  │
│  │    referenced in the body                                              │  │
│  │    Remove unused captures (e.g., from pre-registered defines)          │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 6. Adjust variable indices (adjust_var_indices)                        │  │
│  │    CRITICAL: Map indices to closure environment layout                 │  │
│  │    Closure env at runtime: [captures..., params..., locals...]         │  │
│  │                                                                         │  │
│  │    For outer lambda:                                                   │  │
│  │    y capture[0] → index = 0                                            │  │
│  │    x param[0]   → index = 1 (= captures.len() + param_pos)             │  │
│  │                                                                         │  │
│  │    For inner lambda:                                                   │  │
│  │    x captured from parent → index = 0                                  │  │
│  │    y param[0]             → index = 1                                  │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 7. Return Expr::Lambda AST node                                        │  │
│  │    Lambda {                                                             │  │
│  │        params: [x],                                                    │  │
│  │        body: <compiled body>,                                          │  │
│  │        captures: [(y, 1, 1)],   // Resolved from scope_stack           │  │
│  │        locals: []               // Phase 4: locally-defined vars       │  │
│  │    }                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                    STAGE 1.5: CAPTURE RESOLUTION                              │
│            (Post-processing: Fix indices for nested captures)                │
│                                                                               │
│  File: src/compiler/capture_resolution.rs                                    │
│  Function: resolve_captures() with env_stack walking                         │
│                                                                               │
│  Purpose: When inner lambda captures from outer lambda, adjust capture       │
│           indices to account for outer lambda's num_captures offset          │
│                                                                               │
│  Algorithm:                                                                  │
│  1. Walk AST, maintaining env_stack of [LambdaEnvInfo]                      │
│  2. For each lambda, build symbol_to_env_index map                          │
│  3. Remap body variables (depth > 0 means "from outer scope")               │
│  4. Fix nested capture indices: index += parent.num_captures                │
│                                                                               │
│  Result: All variable references use correct environment indices            │
│          accounting for runtime closure environment layout                   │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                         STAGE 2: COMPILER                                     │
│                  (Expr AST → Bytecode Instructions)                           │
│                                                                               │
│  File: src/compiler/compile.rs                                               │
│  Function: compile_expr() with Lambda pattern                                │
│                                                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 1. Create compiler context                                             │  │
│  │    lambda_locals: []                                                   │  │
│  │    lambda_captures_len: 1 (y)                                          │  │
│  │    lambda_params_len: 1 (x)                                            │  │
│  │    scope_depth: 0 (NO SCOPE STACK for lambdas in Phase 4)              │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 2. Compile body expressions (recursively)                              │  │
│  │    compile_expr(body, tail=true)                                       │  │
│  │    Generate bytecode for all expressions                               │  │
│  │    Emit Return instruction at end                                      │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 3. Create Closure value (template)                                     │  │
│  │    Closure {                                                            │  │
│  │        bytecode: <compiled instructions>,                              │  │
│  │        arity: Arity::Exact(1),        // num params                    │  │
│  │        env: Rc::new(Vec::new()),      // Empty at compile time         │  │
│  │        num_locals: 1 + 1 + 0,         // params + captures + locals    │  │
│  │        num_captures: 1,                                                │  │
│  │        constants: <constants table>                                    │  │
│  │    }                                                                    │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ 4. Emit closure creation instructions                                  │  │
│  │                                                                         │  │
│  │    Since has captures (y):                                             │  │
│  │    emit(LoadUpvalueRaw(1, 0))  // Load y from outer closure            │  │
│  │                                // (depth=1, index=0)                   │  │
│  │                                                                         │  │
│  │    Check if y is mutated via analyze_mutated_vars():                   │  │
│  │    If yes: emit(MakeCell)      // Wrap in Rc<RefCell<>>               │  │
│  │                                                                         │  │
│  │    emit(MakeClosure(closure_template, 1))  // Create with 1 capture    │  │
│  │                                                                         │  │
│  │    Stack effect: ... y (or Cell(y)) → ... Closure(y)                   │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│                        Bytecode Instructions Generated:                       │
│                        • LoadUpvalueRaw(1, 0)   // y                         │
│                        • MakeClosure(tmpl, 1)   // Create closure            │
│                        • Return                 // Return closure            │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│                          STAGE 3: VM EXECUTION                                │
│                 (Bytecode Execution + Variable Binding)                       │
│                                                                               │
│  File: src/vm/mod.rs + src/vm/variables.rs                                   │
│  Instructions: LoadUpvalue, StoreUpvalue, LoadGlobal, MakeClosure            │
│                                                                               │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ At lambda call time:                                                   │  │
│  │                                                                         │  │
│  │ 1. Call handler processes MakeClosure instructions                     │  │
│  │    Stack: [arg_1, ..., arg_n, Closure(bytecode, env)]                 │  │
│  │                                                                         │  │
│  │ 2. Extract captured values from stack in order                         │  │
│  │    For each capture: Load value from caller's closure env              │  │
│  │    For symbols (globals): Keep as symbols for runtime lookup           │  │
│  │    For cells: Preserve cell wrapper (or rewrap mutated vars)           │  │
│  │                                                                         │  │
│  │ 3. Create new environment Rc<Vec<Value>>:                              │  │
│  │    Index 0: captured y value (or Cell if mutated)                      │  │
│  │    Index 1: arg_1 (x parameter)                                        │  │
│  │    Index 2+: locally-defined variables (if any)                        │  │
│  │                                                                         │  │
│  │    Closure env layout: [captures..., params..., locals...]             │  │
│  │                                                                         │  │
│  │ 4. Execute lambda bytecode with closure_env available                 │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                    │                                          │
│                                    ▼                                          │
│  ┌────────────────────────────────────────────────────────────────────────┐  │
│  │ During lambda body execution:                                          │  │
│  │                                                                         │  │
│  │ LoadUpvalue(depth, index):   Load from closure_env[index]              │  │
│  │    If Cell wrapper: Transparently unwrap and push value                │  │
│  │    If Symbol: Look up in globals.get(sym_id)                           │  │
│  │                                                                         │  │
│  │ StoreUpvalue(depth, index):  Store to closure_env[index]               │  │
│  │    If Cell wrapper: Update cell contents (mutates shared state)        │  │
│  │    Otherwise: Replace value in closure_env                             │  │
│  │                                                                         │  │
│  │ LoadGlobal(sym_id):          Load from global scope                    │  │
│  │    Check scope_stack first                                             │  │
│  │    Then check globals map                                              │  │
│  │    Error if not found: "Undefined global variable"                     │  │
│  └────────────────────────────────────────────────────────────────────────┘  │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘

================================================================================
                           CLOSURE ENVIRONMENT LAYOUT
================================================================================

Runtime structure of Rc<Vec<Value>> for lambda with:
  - 2 captures (y, z)
  - 1 parameter (x)
  - 1 locally-defined variable (a from "define a ...")

    ┌─────────────────────┐
    │    Closure Env      │
    │ Rc<Vec<Value>>      │
    ├─────────────────────┤
    │ [0]: y (or Cell(y)) │ ◄── Captures (from outer scope)
    │ [1]: z (or Cell(z)) │
    ├─────────────────────┤
    │ [2]: x (parameter)  │ ◄── Parameters
    ├─────────────────────┤
    │ [3]: Cell(a)        │ ◄── Locals (always cells for mutability)
    └─────────────────────┘

Index calculation at compile time:
  - Capture: index = capture_pos                    // 0, 1
  - Parameter: index = captures.len() + param_pos  // 2
  - Local: index = captures.len() + params.len() + local_pos  // 3

================================================================================
                          VARIABLE TYPE HANDLING
================================================================================

┌──────────────────┬────────────────┬─────────────────┬──────────────────────┐
│ Variable Type    │ Scope          │ Storage         │ Access Instruction   │
├──────────────────┼────────────────┼─────────────────┼──────────────────────┤
│ Parameter        │ Lambda         │ Closure env[1+] │ LoadUpvalue(0, idx)  │
│ Captured local   │ Outer lambda   │ Closure env[0+] │ LoadUpvalue(0, idx)  │
│ Locally-defined  │ Lambda body    │ Closure env[2+] │ LoadUpvalue(0, idx)  │
│ Global           │ Global scope   │ Symbol constant │ LoadGlobal(sym_id)   │
│                  │                │ → globals map   │                      │
├──────────────────┼────────────────┼─────────────────┼──────────────────────┤
│ Mutated capture  │ Outer lambda   │ Cell(value)     │ LoadUpvalue unwraps  │
│ Mutated local    │ Lambda body    │ Cell(value)     │ StoreUpvalue wraps   │
└──────────────────┴────────────────┴─────────────────┴──────────────────────┘

================================================================================
                        NESTED LAMBDA COMPILATION
================================================================================

Example: (lambda (x) (lambda (y) (+ x y)))

Outer Lambda:
  params: [x]
  captures: []
  locals: []
  body: (lambda (y) (+ x y))

Inner Lambda (compiled as part of outer's body):
  params: [y]
  captures: [(x, 0, 0)]  ◄── x from outer lambda scope
  locals: []
  body: (+ x y)

At inner lambda compilation, captures are marked with:
  - depth=0: x is in outer lambda's scope (0 scopes away)
  - index=0: x is at position 0 in outer lambda's environment

During capture resolution (capture_resolution.rs):
  - Check if outer lambda has captures: it doesn't
  - So inner lambda's x capture index stays 0
  - x will be loaded via LoadUpvalue from outer closure env[0]

Multi-level nesting:
  (lambda (x) (lambda (y) (lambda (z) (+ x y z))))

Inner-inner Lambda:
  params: [z]
  captures: [(x, 1, ?), (y, 0, ?)]
  - x is 1 level away (in outer-outer lambda)
  - y is 0 levels away (in outer lambda)
  
Capture resolution fixes indices based on num_captures of intermediate lambdas.

================================================================================
                         PHASE 4: CELL BOXING
================================================================================

For mutable captures (set! on captured variables):

Compile-time (compile.rs):
  1. analyze_mutated_vars() identifies which captures are mutated
  2. For each mutated capture:
     emit(LoadUpvalueRaw(depth, index))
     emit(MakeCell)  // Wrap value in Rc<RefCell<Box<Value>>>

Runtime (vm/mod.rs at Call):
  1. Pre-allocate Value::Cell slots for locally-defined variables
  2. When parameter is accessed via LoadUpvalue:
     - If it's a Cell: transparently unwrap to get value
     - If it's not: return as-is

MutateCell is idempotent:
  - MakeCell(Cell(x)) → Cell(x)  // Don't double-wrap
  - MakeCell(x) → Cell(x)        // Wrap once

Result: Nested closures can mutate shared state via cells.
  (define a 10)
  (define f (lambda () (set! a 20)))
  (define g (lambda () (set! a 30)))
  (f) (g) a  ◄── a is now 30 (shared mutable state)

================================================================================
