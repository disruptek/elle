================================================================================
                    SIDE-BY-SIDE SYNTAX COMPARISON
================================================================================

SIMPLE LOOP: Sum numbers 1-10

┌─ JANET ──────────────────────────────────────────────────────────────────┐
│ (var sum 0)                                                               │
│ (for i in (range 1 11)                                                   │
│   (set sum (+ sum i)))                                                   │
│ (print sum)                                                              │
└──────────────────────────────────────────────────────────────────────────┘

┌─ CLOJURE (doseq - eager) ─────────────────────────────────────────────────┐
│ (def sum (atom 0))                                                       │
│ (doseq [i (range 1 11)]                                                  │
│   (swap! sum + i))                                                       │
│ (println @sum)                                                           │
└──────────────────────────────────────────────────────────────────────────┘

┌─ CLOJURE (for - lazy) ────────────────────────────────────────────────────┐
│ (def result (for [i (range 1 11)] i))                                   │
│ (println (apply + result))  ; realizes the lazy seq                     │
└──────────────────────────────────────────────────────────────────────────┘

┌─ SCHEME ──────────────────────────────────────────────────────────────────┐
│ (define sum 0)                                                           │
│ (for-each (lambda (i)                                                    │
│              (set! sum (+ sum i)))                                       │
│           (iota 10 1))                                                   │
│ (display sum)                                                            │
└──────────────────────────────────────────────────────────────────────────┘

┌─ COMMON LISP ─────────────────────────────────────────────────────────────┐
│ (let ((sum 0))                                                           │
│   (dolist (i (loop for i from 1 to 10 collect i))                       │
│     (setf sum (+ sum i)))                                               │
│   (print sum))                                                           │
└──────────────────────────────────────────────────────────────────────────┘

┌─ ELLE (CURRENT - RECOMMENDED) ────────────────────────────────────────────┐
│ (define sum 0)                                                           │
│ (for i (range 1 11)                                                      │
│   (set! sum (+ sum i)))                                                 │
│ (print sum)                                                              │
└──────────────────────────────────────────────────────────────────────────┘

================================================================================

NESTED LOOP: Print all combinations

┌─ JANET ──────────────────────────────────────────────────────────────────┐
│ (for x in [1 2 3]                                                        │
│   (for y in [a b]                                                        │
│     (print [x y])))                                                      │
└──────────────────────────────────────────────────────────────────────────┘

┌─ CLOJURE (doseq - native multi-seq) ──────────────────────────────────────┐
│ (doseq [x [1 2 3] y [:a :b]]                                            │
│   (println [x y]))                                                       │
└──────────────────────────────────────────────────────────────────────────┘

┌─ SCHEME ──────────────────────────────────────────────────────────────────┐
│ (for-each (lambda (x)                                                    │
│             (for-each (lambda (y)                                        │
│                         (display [x y]))                                 │
│                       '(a b)))                                           │
│           '(1 2 3))                                                      │
└──────────────────────────────────────────────────────────────────────────┘

┌─ COMMON LISP ─────────────────────────────────────────────────────────────┐
│ (dolist (x '(1 2 3))                                                     │
│   (dolist (y '(a b))                                                     │
│     (print (list x y))))                                                │
└──────────────────────────────────────────────────────────────────────────┘

┌─ ELLE (CURRENT - RECOMMENDED) ────────────────────────────────────────────┐
│ (for x [1 2 3]                                                            │
│   (for y ['a 'b]                                                         │
│     (print [x y])))                                                      │
└──────────────────────────────────────────────────────────────────────────┘

================================================================================

OBSERVATIONS:

1. READABILITY RANKING (best to worst):
   1. Elle, Janet - simple and direct
   2. Clojure (doseq) - clear but square brackets less familiar
   3. Common Lisp - more verbose but explicit
   4. Scheme - more verbose, lambda syntax overhead
   5. Clojure (for) - works but semantics are different

2. SIMILARITY TO ELLE:
   ✓✓✓ Janet - nearly identical (modern Lisp standard)
   ✓✓  Clojure doseq - similar semantics, different syntax
   ✓   Common Lisp - same purpose, more verbose
   ~   Scheme - same purpose, functional approach
   ✗   Clojure for - different semantics (lazy)

3. NAMING CONSISTENCY:
   ✓ Elle "for" matches Janet "for" (modern convention)
   ~ Elle "for" matches Common Lisp intent (but not name)
   ~ Elle "for" is eager unlike Clojure "for" (which is lazy)
   ✗ Elle "for" differs from Scheme "for-each" (functional style)

4. SYNTAX CONSISTENCY:
   ✓ Elle (for item iter body) - clean and minimal
   ✓ Janet (for item in iter body) - adds optional 'in' keyword
   ~ Clojure (doseq [items] body) - vector binding syntax
   ~ Common Lisp (dolist (var list) body) - parentheses binding
   ✗ Scheme (for-each fn list...) - functional application

================================================================================

VERDICT: Elle's `for` is optimally designed for its purpose.

It combines:
  • Modern naming convention (Janet-aligned)
  • Simple, clean syntax
  • Intuitive semantics
  • Clear purpose for eager iteration with side effects

NO RENAME IS NECESSARY.

================================================================================
