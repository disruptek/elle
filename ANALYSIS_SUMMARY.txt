================================================================================
RESIDENT COMPILER ERROR HANDLING ANALYSIS - EXECUTIVE SUMMARY
================================================================================

PROJECT: Elle Language Compiler
COMPONENT: Resident Compiler (LSP + CLI shared compilation interface)
ANALYSIS SCOPE: Error message structure, source location tracking, and formatting

================================================================================
KEY FINDINGS
================================================================================

1. ERROR MESSAGE STRUCTURE
   ========================
   
   The resident_compiler uses THREE DISTINCT ERROR LEVELS:
   
   A. CompileError (Compilation Stage)
      - Location: src/resident_compiler/compiler.rs (lines 11-22)
      - Type: Simple string-based error wrapper
      - When: Lexing, parsing, conversion, file I/O failures
      - Display: "LexerError: ...", "Parse error: ...", etc.
      - Limitation: No location information attached
   
   B. Diagnostic (Linting Stage)
      - Location: src/compiler/linter/diagnostics.rs
      - Type: Structured error with location, severity, code, and suggestions
      - When: Static analysis on valid AST
      - Display: "line:col severity: rule\n  message: ...\n  suggestions: ..."
      - Strengths: Rich metadata, actionable suggestions
   
   C. RuntimeError (Execution Stage)
      - Location: src/error/runtime.rs (lines 7-50)
      - Type: Error with optional location and context
      - Display: "Error at file:line:col: message\n  Context: ..."
      - Pattern: Builder pattern for flexible construction

2. SOURCE LOCATION INFRASTRUCTURE (SourceLoc)
   ============================================
   
   Core Structure: src/reader/token.rs (lines 1-42)
   ```
   struct SourceLoc {
       file: String,    // Source file name or "<unknown>"
       line: usize,     // 1-indexed line number
       col: usize,      // 1-indexed column number
   }
   ```
   
   Display Format: "file:line:col" (e.g., "script.lisp:5:10")
   
   Factory Methods:
   - new(file, line, col)    : Full constructor
   - from_line_col(l, c)     : With default file "<unknown>"
   - start()                  : File beginning (1:1)
   
   Usage Points:
   - Lexer: Creates SourceLoc for each token via get_loc()
   - Tokens: TokenWithLoc pairs token + SourceLoc
   - AST: ExprWithLoc wraps expressions with optional SourceLoc
   - Diagnostics: Each diagnostic carries SourceLoc

3. LOCATION TRACKING DURING COMPILATION
   =====================================
   
   Pipeline Flow:
   Source Text
       ↓ (Lexer generates TokenWithLoc with SourceLoc)
   Tokens with Location
       ↓ (Reader parses into Values)
   Values (location implicit)
       ↓ (Converter generates Expr)
   Expr (location LOST - Phase 2 TODO)
       ↓ (Wrapped in ExprWithLoc with None)
   ExprWithLoc { expr, loc: None }
       ↓ (Compiled to Bytecode)
   Bytecode + empty LocationMap
       ↓ (Linter analyzes AST)
   Vec<Diagnostic> with SourceLoc
       ↓
   CompiledDocument (complete result)
   
   LocationMap: HashMap<usize, SourceLoc>
   - Type: src/error/mod.rs (lines 21-26)
   - Purpose: Map bytecode instruction indices back to source locations
   - Status: Currently empty (Phase 2 implementation planned)
   - Storage: Held in VM for runtime error reporting

4. ERROR FORMATTING FOR DISPLAY
   =============================
   
   A. RuntimeError.fmt()
      Input: message, optional location, optional context
      Format: 
        "Error at file:line:col: message\n  Context: context"
        OR
        "Error: message\n  Context: context"
      Location: error/runtime.rs lines 37-50
   
   B. Diagnostic.format_human()
      Input: severity, rule, message, location, suggestions
      Format:
        "line:col severity: rule\n  message: ...\n  suggestions:\n    - ..."
      Location: compiler/linter/diagnostics.rs lines 58-84
   
   Display Patterns:
   - Severity: "error", "warning", "info" (ordered: Info < Warning < Error)
   - Codes: "W001" (naming), "W002" (arity), etc.
   - Rules: "naming-kebab-case", "arity-mismatch", etc.

5. SHARED ERROR INFRASTRUCTURE
   =============================
   
   A. Diagnostic System
      Location: compiler/linter/
      Components:
      - Severity enum: Info, Warning, Error (ordered)
      - Diagnostic struct: Complete error metadata
      - Suggestions: Actionable fixes (e.g., "rename to my-variable")
      
      Example Rules:
      - "naming-kebab-case" (W001): Identifier formatting
      - "arity-mismatch" (W002): Function argument count
      
   B. Linter Engine
      Location: compiler/linter/mod.rs
      Process:
      1. lint_expr(expr_with_loc, symbol_table)
      2. Traverses AST recursively via check_expr()
      3. Passes location through entire traversal
      4. Calls rule checkers with location
      5. Collects all diagnostics
      
   C. CompiledDocument
      Location: resident_compiler/compiled_doc.rs
      Contents:
      - source_text: Original source code
      - ast: ExprWithLoc (AST with location)
      - bytecode: Compiled instructions
      - location_map: LocationMap (instruction → location)
      - symbols: SymbolIndex for IDE
      - diagnostics: Vec<Diagnostic> from linter
      - compiled_at: Compilation timestamp

================================================================================
COMPILATION PIPELINE - COMPLETE FLOW
================================================================================

compile_text(name: &str, text: &str) → Result<CompiledDocument>

1. LEXING (Lines 87-105)
   - Create: Lexer::with_file(text, name)
   - Loop: Collect tokens until EOF
   - Error: CompileError wrapping LexerError
   - Output: Vec<OwnedToken>

2. PARSING (Lines 107-113)
   - Create: Reader::new(tokens)
   - Parse: reader.read(&mut symbol_table)
   - Error: CompileError wrapping ParseError
   - Output: Value

3. CONVERSION (Lines 115-119)
   - Convert: value_to_expr(value, &mut symbol_table)
   - Error: CompileError wrapping ConversionError
   - Output: Expr
   - ISSUE: Location information lost here

4. AST WRAPPING (Lines 121-125)
   - Wrap: ExprWithLoc { expr, loc: None }
   - ISSUE: Location set to None (Phase 2 TODO)

5. BYTECODE COMPILATION (Lines 128)
   - Compile: compile_with_metadata(expr, None)
   - Output: (Bytecode, LocationMap)
   - ISSUE: LocationMap is empty (Phase 2 TODO)

6. LINTING (Lines 134-136)
   - Create: Linter::new()
   - Lint: linter.lint_expr(expr_with_loc, &symbol_table)
   - Output: Vec<Diagnostic> with optional SourceLoc

7. RESULT COLLECTION (Lines 138-145)
   - Create: CompiledDocument::new(...)
   - Cache: memory_cache.put(name, doc.clone())
   - Return: Ok(doc)

================================================================================
KEY PATTERNS AND PRACTICES
================================================================================

Pattern 1: Error Wrapping
  some_operation()
    .map_err(|e| CompileError {
        message: format!("Context prefix: {}", e),
    })?

Pattern 2: Location-Aware Diagnostic
  Diagnostic::new(severity, code, rule, message, location)
    .with_suggestions(vec![...])

Pattern 3: Builder Pattern
  RuntimeError::new("message")
    .with_location(loc)
    .with_context("context")

Pattern 4: Recursive AST Traversal
  fn check_expr(&mut self, expr: &Expr, loc: &Option<SourceLoc>, ...) {
      match expr {
          Expr::Call { func, args, .. } => {
              // Pass location to all sub-checks
              self.check_expr(func, loc, ...);
              for arg in args {
                  self.check_expr(arg, loc, ...);
              }
          }
          ...
      }
  }

================================================================================
CRITICAL FILES - QUICK REFERENCE
================================================================================

ERROR TYPES:
  resident_compiler/compiler.rs (234 lines)    - CompileError
  error/runtime.rs (53 lines)                   - RuntimeError
  compiler/linter/diagnostics.rs (120 lines)    - Diagnostic + Severity

LOCATION TRACKING:
  reader/token.rs (119 lines)                   - SourceLoc + TokenWithLoc
  compiler/ast.rs (223 lines)                   - ExprWithLoc
  error/mod.rs (338 lines)                      - LocationMap type alias

COMPILATION:
  resident_compiler/compiler.rs (234 lines)    - ResidentCompiler.compile_text()
  compiler/compile/mod.rs (1150+ lines)        - compile_with_metadata()

LINTING:
  compiler/linter/mod.rs (262 lines)           - Linter engine
  compiler/linter/rules.rs (194 lines)         - Linting rules

RESULTS:
  resident_compiler/compiled_doc.rs (67 lines) - CompiledDocument

================================================================================
KNOWN LIMITATIONS
================================================================================

1. Location Loss in Conversion
   Status: KNOWN ISSUE (Phase 2)
   Problem: Converting Value → Expr loses location information
   Effect: ExprWithLoc.loc is always None
   Impact: Diagnostics cannot report precise locations

2. Empty LocationMap
   Status: KNOWN ISSUE (Phase 2)
   Problem: Bytecode instruction → location mapping not populated
   Effect: Runtime errors cannot be mapped back to source
   Impact: VM has LocationMap infrastructure but it's unused

3. CompileError Lacks Location
   Status: LIMITATION
   Problem: CompileError is simple string-based, no SourceLoc field
   Effect: Lexing/parsing errors don't carry location info
   Impact: Users see "Lexer error: ..." without line/column

4. Location Lost During Conversion
   Status: ARCHITECTURAL (Phase 2)
   Problem: Value type doesn't carry location metadata
   Impact: Need to thread location through value_to_expr()

================================================================================
PROPOSED IMPROVEMENTS (PHASE 2+)
================================================================================

1. Preserve Location Through Conversion
   - Add location parameter to value_to_expr()
   - Thread location through AST construction
   - Result: Diagnostic messages with precise locations

2. Populate LocationMap During Compilation
   - Track bytecode instruction generation
   - Record source location for each instruction
   - Result: Accurate runtime error reporting

3. Enhance CompileError
   - Add Optional<SourceLoc> field
   - Add CompileStage enum (Lex, Parse, Convert, etc.)
   - Result: Better error context for compilation failures

4. Add Location Tracking to VM
   - Use LocationMap during execution
   - Report location in runtime errors
   - Result: Stack traces with source locations

================================================================================
SUMMARY
================================================================================

The resident_compiler uses a well-designed three-level error architecture
with structured diagnostics at the compilation/linting stage. Source location
information (SourceLoc) is generated at the lexer level and carried through
tokens. However, location information is currently lost during AST conversion
and bytecode compilation (Phase 2 TODO items).

The linting infrastructure is robust and provides actionable suggestions with
severity levels. The planned Phase 2 improvements will integrate location
tracking throughout the entire compilation pipeline, enabling precise error
reporting from lexing through runtime execution.

KEY STRENGTHS:
  - Well-structured Diagnostic system with suggestions
  - Builder pattern for flexible error construction
  - Severity levels for error prioritization
  - Comprehensive linting rules infrastructure

KEY IMPROVEMENTS NEEDED:
  - Thread location through Value→Expr conversion
  - Populate LocationMap during bytecode generation
  - Attach location to compilation-stage errors
  - Implement location tracking in VM execution

================================================================================
