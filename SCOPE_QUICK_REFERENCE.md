# Elle Scope Implementation: Quick Reference Guide

## File Structure Overview

```
src/compiler/
├── scope.rs           [✓ Implemented] Compile-time scope tracking
├── compile.rs         [✗ Broken] Bytecode generation - ignores scopes
├── converters.rs      [⚠ Partial] Value→Expr, tracks scopes locally only
├── analysis.rs        [⚠ Partial] Free variable analysis
└── ast.rs             [✗ Unused] ScopeVar, ScopeEntry, ScopeExit defined

src/vm/
├── scope.rs           [⚠ Stub] RuntimeScope, ScopeStack implemented
│                               but mostly unused at runtime
├── mod.rs             [✗ Broken] Instruction dispatch - calls scope handlers
│                               but never populates ScopeStack
├── variables.rs       [✗ Broken] LoadGlobal/LoadUpvalue/StoreLocal
│                               don't use ScopeStack
└── stack.rs           [✗ Broken] StoreLocal uses raw stack indices
```

## Current Variable Access Flow

### For Loop Variables (BROKEN)
```
Code: (for x lst body)
  ↓ Conversion (converters.rs)
  Creates: Expr::For { var: x, iter: lst, body }
  ↓ Compilation (compile.rs:283-348)
  Emits: StoreGlobal (x)    ← WRONG: Should emit PushScope/PopScope
  ↓ Execution (mod.rs:95-165)
  Looks up x in vm.globals ← WRONG: x should be in ScopeStack
  Result: x persists after loop exits
```

### Let Variables (BROKEN BUT SOMETIMES WORKS)
```
Code: (let ((x 5)) (+ x 1))
  ↓ Conversion (converters.rs:363-438)
  Creates: Expr::Call {
    func: Expr::Lambda { params: [x], body: (+ x 1) },
    args: [5]
  }
  ↓ Compilation (compile.rs:157-194)
  Emits: MakeClosure, LoadConst(5), Call
  ↓ Execution (mod.rs:107-160)
  Closure environment: [5]
  LoadUpvalue accesses closure.env[0]
  Result: x accessible only inside lambda - WORKS!
          But not via ScopeStack, so other features break
```

### Closure Variables (BROKEN FOR NON-GLOBALS)
```
Code: (define y 10) (lambda (x) (+ x y))
  ↓ Conversion (converters.rs:334-344)
  Captures: [(y, 0, 0)]  ← Placeholder depth/index (0, 0)
  ↓ Compilation (compile.rs:183-188)
  Emits: LoadGlobal(y)  ← Assumes y is global!
  ↓ Execution (mod.rs:145-150)
  Closure env: [value_of_y_from_global]
  Result: Can only capture globals, not parent function vars
```

### Global Variables (WORKS)
```
Code: (define x 5) (+ x 1)
  ↓ Conversion: Expr::GlobalVar(x)
  ↓ Compilation: LoadGlobal
  ↓ Execution: vm.globals[x.0]
  Result: Works perfectly
```

## Key Data Structures

### CompileScope (src/compiler/scope.rs)
```rust
pub struct CompileScope {
    frames: Vec<ScopeFrame>,  // Stack of scopes
}

pub struct ScopeFrame {
    pub variables: HashMap<u32, VariableBinding>,
    pub scope_type: ScopeType,  // Global, Function, Block, Loop, Let
    pub depth: usize,  // Distance from global
}

pub struct VariableBinding {
    pub symbol_id: SymbolId,
    pub binding_type: BindingType,  // Parameter, Local, Captured
    pub depth: usize,  // 0 = current scope, 1 = parent, etc.
    pub index: usize,  // Position within scope
}
```

**Status**: Implemented but NEVER USED in actual compilation!
**Used only in**: Tests (`tests/unittests/scope_compilation.rs`)

### ScopeStack (src/vm/scope.rs)
```rust
pub struct ScopeStack {
    stack: Vec<RuntimeScope>,  // Stack of runtime scopes
}

pub struct RuntimeScope {
    pub variables: HashMap<u32, Value>,  // symbol_id -> Value
    pub scope_type: ScopeType,
}
```

**Methods**:
- `push(scope_type)` - Add new scope
- `pop()` - Remove current scope (keeps Global)
- `get(sym_id)` - Walk up scope chain to find variable
- `set(sym_id, value)` - Update in scope where defined
- `define_local(sym_id, value)` - Add to current scope

**Status**: Fully implemented but NEVER POPULATED!
- `vm.scope_stack` exists (core.rs line 26)
- Never pushed/popped except in tests
- Never consulted for variable access

## Expression Types

### Expr::Var (Used for locals in closures)
```rust
Expr::Var(SymbolId, usize, usize)  // (symbol, depth, index)
```

Compilation: → `LoadUpvalue` instruction
Usage: ONLY works inside closures (LoadUpvalue checks closure_env)
Problem: Used for all non-global variables, but fails outside closures

### Expr::GlobalVar (Used for globals)
```rust
Expr::GlobalVar(SymbolId)
```

Compilation: → `LoadGlobal` instruction
Usage: Always works
Problem: Loop vars and let-bindings incorrectly stored as globals

### Expr::ScopeVar (DEAD CODE)
```rust
Expr::ScopeVar(usize, usize)  // (depth, index)
```

Compilation: → `LoadUpvalue` (WRONG TYPE!)
Should emit: `LoadScoped` instruction
Status: Never generated by converters
Result: Dead code, useless

### Expr::Set (Mutation)
```rust
Expr::Set { var, depth, index, value }
```

Compilation logic:
- If `index == usize::MAX`: → `StoreGlobal` (global var)
- If `depth == 0`: → `StoreLocal` (local var)
- If `depth > 0`: → `StoreGlobal` (WRONG! upvalue not supported)

Problem: No instruction for storing upvalues/scoped vars

## Bytecode Instructions (src/compiler/bytecode.rs)

### Working:
- **LoadGlobal** (u16 const_idx) - Load from vm.globals
- **StoreGlobal** (u16 const_idx) - Store to vm.globals
- **LoadUpvalue** (u8 depth, u8 index) - Load from closure_env
- **LoadConst** (u16 const_idx) - Push constant to stack
- **Call**, **TailCall** - Function call

### Partially Working:
- **LoadLocal** (u8 index) - Load from stack[index]
- **StoreLocal** (u8 index) - Store to stack[index]
  Problem: Raw stack manipulation, no scope awareness

### Stubbed Out:
- **PushScope** (u8 scope_type) - Implemented in handler but never emitted
- **PopScope** - Implemented in handler but never emitted
- **LoadScoped** (u8 depth, u8 index) - Implemented as no-op
- **StoreScoped** (u8 depth, u8 index) - Implemented but incomplete
- **DefineLocal** (u16 sym_idx) - Implemented but never used

## Test Files

### Unit Tests (tests/unittests/)
- `scope_compilation.rs` - Tests CompileScope structure
- `closures_and_lambdas.rs` - Tests closure behavior
- `loops.rs` - Tests loop behavior

### Integration Tests (tests/integration/)
- `loops.rs` - Tests for/while loops
- `closures_and_lambdas.rs` - Tests lambda execution
- `advanced.rs` - Tests complex scoping scenarios

### VM Tests (tests/vm/)
- `scope_test.rs` - Tests ScopeStack structure and handlers

## Known Working Scenarios

✓ Global variables (define + access)
✓ Lambda parameters (captured in closure env)
✓ Let-bindings (transformed to lambda)
✓ Basic closures capturing globals
✓ Function calls and tail calls
✓ If/then/else expressions
✓ Begin blocks

## Known Broken Scenarios

✗ Loop variables (for/while) - persist after loop exits
✗ Variables defined in loop bodies - become globals
✗ Nested loops - interfere with each other
✗ Closures capturing from parent functions - not possible
✗ Multiple let-bindings with dependencies - need let*
✗ Set! on parent scope variables - not properly scoped
✗ Block scopes - not created at runtime
✗ Upvalue mutation - no instruction for it
✗ Dynamic variable lookup - ScopeStack never used

## Quick Debug Checklist

When variable access fails:

1. **Is it in vm.globals?**
   - If yes: LoadGlobal finds it
   - If no: Check if it should be in ScopeStack

2. **Is it inside a lambda/closure?**
   - If yes: Check closure.env
   - If no: Should be in ScopeStack (but it won't be)

3. **Is it a loop variable?**
   - Currently: Stored as global (BUG)
   - Should be: In ScopeStack with Loop scope type

4. **Is it a let-bound variable?**
   - Currently: Works because lambda creates closure env
   - But: Only accessible via LoadUpvalue in that closure

5. **Is ScopeStack being used?**
   - Currently: NO
   - Check: No PushScope/PopScope emitted
   - Check: No DefineLocal called at runtime
   - Verify: vm.scope_stack.depth() == 1 (only global)

## Common Fixes Needed

### For Loop Variables
```rust
// CURRENT (compile.rs:314-316)
self.bytecode.emit(Instruction::StoreGlobal);

// SHOULD BE
self.bytecode.emit(Instruction::PushScope);
self.bytecode.emit_byte(ScopeType::Loop as u8);
// ... body ...
self.bytecode.emit(Instruction::PopScope);
```

### Closure Captures
```rust
// CURRENT (compile.rs:186)
self.bytecode.emit(Instruction::LoadGlobal);

// SHOULD BE (depends on capture depth)
if capture_is_global {
    self.bytecode.emit(Instruction::LoadGlobal);
} else {
    self.bytecode.emit(Instruction::LoadScoped);
    self.bytecode.emit_byte(capture_depth as u8);
}
```

### Variable Mutation
```rust
// CURRENT (compile.rs:217-227)
if depth == 0 {
    self.bytecode.emit(Instruction::StoreLocal);
} else {
    self.bytecode.emit(Instruction::StoreGlobal);  // ← WRONG
}

// SHOULD BE
if depth == 0 {
    self.bytecode.emit(Instruction::StoreLocal);
} else if is_in_closure {
    // Need new instruction: StoreUpvalue
} else {
    self.bytecode.emit(Instruction::StoreScoped);
}
```

