{
  "title": "Concurrency Guide",
  "description": "Concurrent programming with spawn and join",
  "sections": [
    {
      "heading": "Overview",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Elle provides concurrency primitives for executing computations in parallel threads. The spawn and join operations allow you to run closures concurrently and retrieve their results."
        }
      ]
    },
    {
      "heading": "Core Concepts",
      "level": 2,
      "content": [
        {
          "type": "list",
          "items": [
            "spawn: Creates a new thread and executes a closure",
            "join: Waits for a thread to complete and returns its result",
            "Thread handles: References to spawned threads used with join",
            "Captured values: Immutable data that closures can use in threads"
          ]
        }
      ]
    },
    {
      "heading": "Basic Usage",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Use spawn to execute a closure in a new thread and join to wait for completion:"
        },
        {
          "type": "code",
          "language": "lisp",
          "code": "; Spawn a simple computation\n(let ((handle (spawn (lambda () (+ 5 10)))))\n  (let ((result (join handle)))\n    (display result)))  ; prints: 15"
        }
      ]
    },
    {
      "heading": "Capturing Immutable Values",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Closures can capture immutable values from their enclosing scope. These values are safely transmitted to the spawned thread:"
        },
        {
          "type": "code",
          "language": "lisp",
          "code": "; Capture variables from outer scope\n(let ((x 42)\n      (y 8))\n  (let ((handle (spawn (lambda () (+ x y)))))\n    (display (join handle))))  ; prints: 50"
        },
        {
          "type": "text",
          "text": "Supported capture types:"
        },
        {
          "type": "list",
          "items": [
            "Primitives: nil, booleans, integers, floats",
            "Strings: immutable text values",
            "Collections: vectors, lists (cons cells), structs",
            "Symbols and keywords"
          ]
        }
      ]
    },
    {
      "heading": "Parallel Execution",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Multiple threads can execute in parallel. Use multiple spawn calls to start several computations:"
        },
        {
          "type": "code",
          "language": "lisp",
          "code": "; Start multiple threads\n(let ((h1 (spawn (lambda () (* 2 3))))\n      (h2 (spawn (lambda () (* 4 5))))\n      (h3 (spawn (lambda () (* 6 7)))))\n  ; Threads execute in parallel while we're here\n  (let ((r1 (join h1))\n        (r2 (join h2))\n        (r3 (join h3)))\n    (display (+ r1 r2 r3))))  ; prints: 62"
        }
      ]
    },
    {
      "heading": "Error Handling",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "If a spawned thread produces an error, join re-raises that error in the calling thread:"
        },
        {
          "type": "code",
          "language": "lisp",
          "code": "; Error in spawned thread\n(try\n  (let ((handle (spawn (lambda () (/ 1 0)))))\n    (join handle))  ; re-raises division by zero error\n  (catch (e)\n    (display \"Caught error: \")\n    (display e)))"
        }
      ]
    },
    {
      "heading": "Thread Isolation",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Each spawned thread runs in its own virtual machine instance with only the built-in primitives. It has no access to the parent thread's global variables or module state."
        }
      ]
    },
    {
      "heading": "Restrictions",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Due to thread safety requirements, closures cannot capture mutable values:"
        },
        {
          "type": "list",
          "items": [
            "Tables (mutable collections) cannot be captured",
            "Native functions cannot be captured",
            "FFI handles cannot be captured",
            "Closures that reference mutable variables cannot be spawned"
          ]
        },
        {
          "type": "text",
          "text": "Attempting to spawn such a closure produces an error with a description of what couldn't be captured."
        }
      ]
    },
    {
      "heading": "Concurrency Primitives Reference",
      "level": 2,
      "content": [
        {
          "type": "table",
          "headers": ["Function", "Description", "Example"],
          "rows": [
            ["(spawn closure)", "Execute closure in a new thread, returns thread handle", "(spawn (lambda () 42))"],
            ["(join handle)", "Wait for thread to complete and return result", "(join handle)"],
            ["(time/sleep seconds)", "Sleep for specified duration", "(time/sleep 1.5)"],
            ["(current-thread-id)", "Get ID of current thread", "(current-thread-id)"]
          ]
        }
      ]
    },
    {
      "heading": "Advanced Patterns",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "Complex computations with multiple captures:"
        },
        {
          "type": "code",
          "language": "lisp",
          "code": "; Capture multiple values for a computation\n(let ((a 2) (b 3) (c 4) (d 5))\n  (let ((handle (spawn (lambda ()\n                         (+ (* a b) (* c d))))))\n    (display (join handle))))  ; prints: 26"
        },
        {
           "type": "text",
           "text": "Using arrays and collections in spawned threads:"
         },
         {
           "type": "code",
           "language": "lisp",
           "code": "; Spawn with array capture\n(let ((numbers [1 2 3 4 5]))\n  (let ((handle (spawn (lambda ()\n                         (+ 1 (+ 2 (+ 3 (+ 4 5))))))))\n    (display (join handle))))  ; prints: 15"
         }
      ]
    },
    {
      "heading": "Performance Considerations",
      "level": 2,
      "content": [
        {
          "type": "list",
          "items": [
            "spawn is lightweight and fast - creates only native OS threads",
            "join blocks the calling thread until the spawned thread completes",
            "Multiple threads can improve performance for CPU-bound tasks on multi-core systems",
            "Thread overhead is small compared to the computation time in most cases"
          ]
        }
      ]
    },
    {
      "heading": "Examples",
      "level": 2,
      "content": [
        {
          "type": "text",
          "text": "See examples/concurrency-spawn-join.lisp for 10 comprehensive examples of spawn and join usage patterns."
        }
      ]
    }
  ]
}
