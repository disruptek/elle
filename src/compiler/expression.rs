use super::ast::Expr;
use super::bytecode::{Bytecode, Instruction};
use crate::symbol::SymbolTable;
use crate::value::{Closure, SymbolId, Value};
use std::collections::HashMap;
use std::rc::Rc;

pub struct Compiler {
    pub bytecode: Bytecode,
    #[allow(dead_code)]
    pub symbols: HashMap<SymbolId, usize>,
}

impl Compiler {
    pub fn new() -> Self {
        Compiler {
            bytecode: Bytecode::new(),
            symbols: HashMap::new(),
        }
    }

    pub fn compile_expr(&mut self, expr: &Expr, tail: bool) {
        match expr {
            Expr::Literal(val) => match val {
                Value::Nil => self.bytecode.emit(Instruction::Nil),
                Value::Bool(true) => self.bytecode.emit(Instruction::True),
                Value::Bool(false) => self.bytecode.emit(Instruction::False),
                _ => {
                    let idx = self.bytecode.add_constant(val.clone());
                    self.bytecode.emit(Instruction::LoadConst);
                    self.bytecode.emit_u16(idx);
                }
            },

            Expr::Var(_sym, depth, index) => {
                if *depth == 0 {
                    self.bytecode.emit(Instruction::LoadLocal);
                    self.bytecode.emit_byte(*index as u8);
                } else {
                    self.bytecode.emit(Instruction::LoadUpvalue);
                    self.bytecode.emit_byte(*depth as u8);
                    self.bytecode.emit_byte(*index as u8);
                }
            }

            Expr::GlobalVar(sym) => {
                let idx = self.bytecode.add_constant(Value::Symbol(*sym));
                self.bytecode.emit(Instruction::LoadGlobal);
                self.bytecode.emit_u16(idx);
            }

            Expr::If { cond, then, else_ } => {
                self.compile_expr(cond, false);
                self.bytecode.emit(Instruction::JumpIfFalse);
                let else_jump = self.bytecode.current_pos();
                self.bytecode.emit_u16(0); // Placeholder

                self.compile_expr(then, tail);
                self.bytecode.emit(Instruction::Jump);
                let end_jump = self.bytecode.current_pos();
                self.bytecode.emit_u16(0); // Placeholder

                let else_pos = self.bytecode.current_pos();
                self.bytecode
                    .patch_jump(else_jump, (else_pos - else_jump - 2) as i16);

                self.compile_expr(else_, tail);

                let end_pos = self.bytecode.current_pos();
                self.bytecode
                    .patch_jump(end_jump, (end_pos - end_jump - 2) as i16);
            }

            Expr::Begin(exprs) => {
                for (i, expr) in exprs.iter().enumerate() {
                    let is_last = i == exprs.len() - 1;
                    self.compile_expr(expr, tail && is_last);
                    if !is_last {
                        self.bytecode.emit(Instruction::Pop);
                    }
                }
            }

            Expr::Call {
                func,
                args,
                tail: is_tail,
            } => {
                // Compile arguments
                for arg in args {
                    self.compile_expr(arg, false);
                }

                // Compile function
                self.compile_expr(func, false);

                // Emit call
                if tail && *is_tail {
                    self.bytecode.emit(Instruction::TailCall);
                } else {
                    self.bytecode.emit(Instruction::Call);
                }
                self.bytecode.emit_byte(args.len() as u8);
            }

            Expr::Lambda {
                params,
                body,
                captures,
            } => {
                // Create a new compiler for the lambda body
                let mut lambda_compiler = Compiler::new();

                // Compile the body
                lambda_compiler.compile_expr(body, true);
                lambda_compiler.bytecode.emit(Instruction::Return);

                // Create closure value with environment
                // Note: env is empty here, actual capturing happens at runtime via MakeClosure instruction
                let closure = Closure {
                    bytecode: Rc::new(lambda_compiler.bytecode.instructions),
                    arity: crate::value::Arity::Exact(params.len()),
                    env: Rc::new(Vec::new()), // Will be populated by VM when closure is created
                    num_locals: params.len() + captures.len(),
                    constants: Rc::new(lambda_compiler.bytecode.constants),
                };

                let idx = self.bytecode.add_constant(Value::Closure(Rc::new(closure)));

                // Emit captured values onto the stack (in order)
                // These will be stored in the closure's environment by the VM
                for (sym, _depth, _index) in captures {
                    // Load the captured variable
                    let sym_idx = self.bytecode.add_constant(Value::Symbol(*sym));
                    self.bytecode.emit(Instruction::LoadGlobal);
                    self.bytecode.emit_u16(sym_idx);
                }

                // Create closure with captured values
                self.bytecode.emit(Instruction::MakeClosure);
                self.bytecode.emit_u16(idx);
                self.bytecode.emit_byte(captures.len() as u8);
            }

            Expr::Let { bindings, body } => {
                // Compile bindings
                for (_name, value_expr) in bindings {
                    self.compile_expr(value_expr, false);
                }

                // Compile body
                self.compile_expr(body, tail);

                // Pop bindings
                for _ in bindings {
                    self.bytecode.emit(Instruction::Pop);
                }
            }

            Expr::Set {
                var: _,
                depth,
                index,
                value,
            } => {
                self.compile_expr(value, false);
                if *depth == 0 {
                    self.bytecode.emit(Instruction::StoreLocal);
                    self.bytecode.emit_byte(*index as u8);
                } else {
                    self.bytecode.emit(Instruction::LoadUpvalue);
                    self.bytecode.emit_byte(*depth as u8);
                    self.bytecode.emit_byte(*index as u8);
                }
            }

            Expr::Define { name, value } => {
                self.compile_expr(value, false);
                let idx = self.bytecode.add_constant(Value::Symbol(*name));
                self.bytecode.emit(Instruction::StoreGlobal);
                self.bytecode.emit_u16(idx);
            }

            Expr::While { cond, body } => {
                // Implement while loop using conditional jumps
                // Loop label - start of condition check
                let loop_label = self.bytecode.instructions.len();

                // Compile condition
                self.compile_expr(cond, false);

                // Jump to end if condition is false
                self.bytecode.emit(Instruction::JumpIfFalse);
                let exit_jump = self.bytecode.instructions.len();
                self.bytecode.emit_i16(0); // Placeholder for exit offset

                // Compile body
                self.compile_expr(body, false);

                // Pop the body result (we don't care about it)
                self.bytecode.emit(Instruction::Pop);

                // Jump back to loop condition
                self.bytecode.emit(Instruction::Jump);
                let loop_offset =
                    (loop_label as i32) - (self.bytecode.instructions.len() as i32 + 2);
                self.bytecode.emit_i16(loop_offset as i16);

                // Patch the exit jump
                let exit_offset =
                    (self.bytecode.instructions.len() as i32) - (exit_jump as i32 + 2);
                let offset_bytes = (exit_offset as i16).to_le_bytes();
                self.bytecode.instructions[exit_jump] = offset_bytes[0];
                self.bytecode.instructions[exit_jump + 1] = offset_bytes[1];

                // Return nil after loop
                self.bytecode.emit(Instruction::Nil);
            }

            Expr::For { var, iter, body } => {
                // Implement for loop: (for x in lst (do-something-with x))
                // Compile the iterable (list)
                self.compile_expr(iter, false);

                // Store the list in a temporary location and iterate through it
                // We'll use the stack to track: car of list | rest of list | original list
                let loop_label = self.bytecode.instructions.len();

                // Check if list is nil (end of iteration)
                self.bytecode.emit(Instruction::Dup); // Duplicate the list
                self.bytecode.emit(Instruction::IsNil);
                self.bytecode.emit(Instruction::JumpIfFalse);
                let body_jump = self.bytecode.instructions.len();
                self.bytecode.emit_i16(0); // Placeholder for jump to body

                // If nil, exit loop
                self.bytecode.emit(Instruction::Pop);
                self.bytecode.emit(Instruction::Nil);
                self.bytecode.emit(Instruction::Jump);
                let exit_jump = self.bytecode.instructions.len();
                self.bytecode.emit_i16(0); // Placeholder for exit

                // Patch body jump
                let body_offset =
                    (self.bytecode.instructions.len() as i32) - (body_jump as i32 + 2);
                let offset_bytes = (body_offset as i16).to_le_bytes();
                self.bytecode.instructions[body_jump] = offset_bytes[0];
                self.bytecode.instructions[body_jump + 1] = offset_bytes[1];

                // Extract car (current element) and cdr (rest)
                self.bytecode.emit(Instruction::Dup); // Duplicate list
                self.bytecode.emit(Instruction::Car); // Get current element
                                                      // Store in variable for body
                let var_idx = self.bytecode.add_constant(Value::Symbol(*var));
                self.bytecode.emit(Instruction::StoreGlobal);
                self.bytecode.emit_u16(var_idx);

                // Get rest for next iteration
                self.bytecode.emit(Instruction::Cdr);

                // Compile body
                self.compile_expr(body, false);
                self.bytecode.emit(Instruction::Pop); // Pop body result

                // Loop back
                self.bytecode.emit(Instruction::Jump);
                let loop_offset =
                    (loop_label as i32) - (self.bytecode.instructions.len() as i32 + 2);
                self.bytecode.emit_i16(loop_offset as i16);

                // Patch exit jump
                let exit_offset =
                    (self.bytecode.instructions.len() as i32) - (exit_jump as i32 + 2);
                let offset_bytes = (exit_offset as i16).to_le_bytes();
                self.bytecode.instructions[exit_jump] = offset_bytes[0];
                self.bytecode.instructions[exit_jump + 1] = offset_bytes[1];
            }

            Expr::Match {
                value,
                patterns,
                default,
            } => {
                // Compile the value to match against
                self.compile_expr(value, false);
                let mut exit_jumps = Vec::new();

                // Try each pattern in sequence
                for (pattern, body_expr) in patterns {
                    let next_pattern_jump = super::pattern::compile_pattern_check(self, pattern);

                    // Pattern matched - pop the value and execute body
                    self.bytecode.emit(Instruction::Pop);
                    self.compile_expr(body_expr, tail);

                    // Jump to end of match
                    self.bytecode.emit(Instruction::Jump);
                    exit_jumps.push(self.bytecode.instructions.len());
                    self.bytecode.emit_i16(0);

                    // Patch the next_pattern_jump to skip to here if pattern doesn't match
                    let skip_to = self.bytecode.instructions.len();
                    for jump_idx in next_pattern_jump {
                        let offset = (skip_to as i32) - (jump_idx as i32 + 2);
                        let offset_bytes = (offset as i16).to_le_bytes();
                        self.bytecode.instructions[jump_idx] = offset_bytes[0];
                        self.bytecode.instructions[jump_idx + 1] = offset_bytes[1];
                    }
                }

                // Default/fallback case
                if let Some(default_expr) = default {
                    self.compile_expr(default_expr, tail);
                } else {
                    self.bytecode.emit(Instruction::Nil);
                }

                // Patch all exit jumps to the end
                let end_pos = self.bytecode.instructions.len();
                for jump_idx in exit_jumps {
                    let offset = (end_pos as i32) - (jump_idx as i32 + 2);
                    let offset_bytes = (offset as i16).to_le_bytes();
                    self.bytecode.instructions[jump_idx] = offset_bytes[0];
                    self.bytecode.instructions[jump_idx + 1] = offset_bytes[1];
                }
            }

            Expr::Try {
                body,
                catch: _,
                finally,
            } => {
                // Try-catch implementation
                // For now: compile body, then optionally execute finally
                // Full exception handling requires VM-level support for stack unwinding

                self.compile_expr(body, false);

                // Finally block: always executed after try/catch
                if let Some(finally_expr) = finally {
                    // Save the result
                    self.bytecode.emit(Instruction::Dup);
                    self.compile_expr(finally_expr, false);
                    self.bytecode.emit(Instruction::Pop);
                    // The original result stays on stack
                }

                // NOTE: Catch handlers will need VM support to:
                // 1. Check if body produced an exception
                // 2. Unwind stack to try frame
                // 3. Bind exception to variable
                // 4. Execute handler
            }

            Expr::Quote { .. } => {
                // Quote is handled during value_to_expr conversion
                // This should not be reached in normal compilation
                self.bytecode.emit(Instruction::Nil);
            }

            Expr::Quasiquote { .. } => {
                // Quasiquote handling not yet implemented
                self.bytecode.emit(Instruction::Nil);
            }

            Expr::Module { .. } => {
                // Module compilation not yet implemented
                self.bytecode.emit(Instruction::Nil);
            }

            Expr::Import { .. } => {
                // Module imports not yet implemented for Phase 2
                // For Phase 2, treat as regular global variable lookup
                self.bytecode.emit(Instruction::Nil);
            }

            Expr::Throw { value: _ } => {
                // Throw is compiled as a function call during value_to_expr
                // This case should never be reached, but we handle it for exhaustiveness
                self.bytecode.emit(Instruction::Nil);
            }
        }
    }

    pub fn finish(self) -> Bytecode {
        self.bytecode
    }
}
