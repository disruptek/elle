//! C function calling primitives.

use super::types::parse_ctype;
use crate::ffi::call::FunctionCall;
use crate::ffi::types::FunctionSignature;
use crate::value::{LibHandle, Value};
use crate::vm::VM;

/// (call-c-function lib-id func-name return-type (arg-type ...) (arg-val ...)) -> result
///
/// Calls a C function with given arguments.
///
/// # Arguments
/// - lib-id: Library handle (from load-library)
/// - func-name: Name of C function as string
/// - return-type: Return type keyword (:int, :float, :double, :void, :pointer, etc.)
/// - arg-types: List of argument type keywords
/// - arg-values: List of argument values to pass
pub fn prim_call_c_function(vm: &VM, args: &[Value]) -> Result<Value, String> {
    if args.len() != 5 {
        return Err("call-c-function requires exactly 5 arguments"
            .to_string()
            .into());
    }

    // Parse library ID
    let lib_id = match &args[0] {
        Value::LibHandle(LibHandle(id)) => *id,
        _ => return Err("First argument must be a library handle".to_string().into()),
    };

    // Parse function name
    let func_name = match &args[1] {
        Value::String(s) => s.as_ref(),
        _ => {
            return Err("Second argument must be a function name string"
                .to_string()
                .into())
        }
    };

    // Parse return type
    let return_type = parse_ctype(&args[2])?;

    // Parse argument types
    let arg_types = match &args[3] {
        Value::Nil => vec![],
        Value::Cons(_) => {
            let type_list = args[3].list_to_vec()?;
            type_list
                .iter()
                .map(parse_ctype)
                .collect::<Result<Vec<_>, _>>()?
        }
        _ => {
            return Err("Fourth argument must be a list of argument types"
                .to_string()
                .into())
        }
    };

    // Parse argument values
    let arg_values = match &args[4] {
        Value::Nil => vec![],
        Value::Cons(_) => args[4].list_to_vec()?,
        _ => {
            return Err("Fifth argument must be a list of argument values"
                .to_string()
                .into())
        }
    };

    // Check argument count matches
    if arg_types.len() != arg_values.len() {
        return Err(format!(
            "Argument count mismatch: expected {}, got {}",
            arg_types.len(),
            arg_values.len()
        ));
    }

    // Create function signature first
    let sig = FunctionSignature::new(func_name.to_string(), arg_types, return_type);

    // Get library and resolve symbol
    let lib = vm
        .ffi()
        .get_library(lib_id)
        .ok_or("Library handle not found".to_string())?;

    // Get function pointer directly from library
    let func_ptr = lib.get_symbol(func_name)?;

    // Create and execute function call
    let call = FunctionCall::new(sig, func_ptr)?;
    call.call(&arg_values)
}

pub fn prim_call_c_function_wrapper(args: &[Value]) -> crate::error::LResult<Value> {
    if args.len() != 5 {
        return Err("call-c-function requires exactly 5 arguments"
            .to_string()
            .into());
    }

    // Parse library ID
    let lib_id = match &args[0] {
        Value::LibHandle(LibHandle(id)) => *id,
        _ => return Err("First argument must be a library handle".to_string().into()),
    };

    // Parse function name
    let func_name = match &args[1] {
        Value::String(s) => s.as_ref(),
        _ => {
            return Err("Second argument must be a function name string"
                .to_string()
                .into())
        }
    };

    // Parse return type
    let return_type = parse_ctype(&args[2])?;

    // Parse argument types
    let arg_types = match &args[3] {
        Value::Nil => vec![],
        Value::Cons(_) => {
            let type_list = args[3].list_to_vec()?;
            type_list
                .iter()
                .map(parse_ctype)
                .collect::<Result<Vec<_>, _>>()?
        }
        _ => {
            return Err("Fourth argument must be a list of argument types"
                .to_string()
                .into())
        }
    };

    // Parse argument values
    let arg_values = match &args[4] {
        Value::Nil => vec![],
        Value::Cons(_) => args[4].list_to_vec()?,
        _ => {
            return Err("Fifth argument must be a list of argument values"
                .to_string()
                .into())
        }
    };

    // Check argument count matches
    if arg_types.len() != arg_values.len() {
        return Err(format!(
            "Argument count mismatch: expected {}, got {}",
            arg_types.len(),
            arg_values.len()
        )
        .into());
    }

    // Create function signature
    let sig = FunctionSignature::new(func_name.to_string(), arg_types, return_type);

    // Get VM context
    let vm_ptr = super::context::get_vm_context().ok_or("FFI not initialized".to_string())?;
    unsafe {
        let vm = &*vm_ptr;
        let lib = vm
            .ffi()
            .get_library(lib_id)
            .ok_or("Library handle not found".to_string())?;

        let func_ptr = lib.get_symbol(func_name)?;
        let call = FunctionCall::new(sig, func_ptr)?;
        call.call(&arg_values).map_err(|e| e.into())
    }
}
